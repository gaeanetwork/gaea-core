package controllers

import (
	"encoding/json"

	"github.com/astaxie/beego"
	"gitlab.com/jaderabbit/go-rabbit/chaincode"
	"gitlab.com/jaderabbit/go-rabbit/tee"
)

// SharedDataController for sharing data uploads, updates, requests, authorizations, and various queries
type SharedDataController struct {
	beego.Controller
}

// Upload used to upload shared data for users. After the data is uploaded, once someone else requests to query this data,
// the user will be notified and can authorize or reject the request.
// @Title Upload
// @Description Upload used to upload shared data for users. After the data is uploaded, once someone else requests to query this data,
// the user will be notified and can authorize or reject the request.
// @Param	ciphertext		formData 	string		true	"Encrypted ciphertext used to share data, usually encrypted with a private key. Of course, you can also not encrypt, upload data plaintext, such as data addresses."
// @Param	summary			formData 	string		true	"A summary of the data shared by the user. It is generally calculated using SM3/SHA-256/MD5. SM3 encryption is currently recommended."
// @Param	description		formData 	string		true	"A data description of the user's shared data. Often used to explain the basics of data or what it can be used for."
// @Param	owner			formData 	string		true	"Data owner for user shared data. Generally use owner public key."
// @Param	hash			formData 	string		false	"All parameters except the signature are sequentially connected to obtain a hash."
// @Param	signatures		formData 	[]string	false	"Signature of the data summary by the user's private key."
// @Success 200 {string} tee.SharedData.ID
// @router / [post]
func (o *SharedDataController) Upload() {
	var data tee.SharedData
	var err error
	if err = o.ParseForm(&data); err != nil {
		responseJSON(o.Controller, false, err.Error())
		return
	}

	logger.Infof("SharedDataController Upload by data: %v ", data)
	server, err := chaincode.GetChaincodeServer(tee.ChaincodeName)
	if err != nil {
		responseJSON(o.Controller, false, err.Error())
		return
	}

	hash := o.GetString("hash")
	if len(data.Signatures) == 0 {
		data.Signatures = make([]string, 1)
	}
	signature, err := json.Marshal(data.Signatures)
	if err != nil {
		responseJSON(o.Controller, false, err.Error())
		return
	}

	result, err := server.Invoke([]string{"upload", data.Ciphertext, data.Hash, data.Description, data.Owner, hash, string(signature)})
	if err != nil {
		responseJSON(o.Controller, false, err.Error())
		return
	}

	var data1 tee.SharedData
	if err = json.Unmarshal([]byte(result), &data1); err != nil {
		responseJSON(o.Controller, false, err.Error())
		return
	}

	responseJSON(o.Controller, true, data1.ID)
}

// GetAll owner can get all the shared data they upload
// @Title GetAll
// @Description owner can get all the shared data they upload
// @Param	owner		query 	string	true		"Data owner for user shared data. Generally use owner public key."
// @Success 200 {object} []tee.SharedData
// @router / [get]
func (o *SharedDataController) GetAll() {
	owner := o.GetString("owner")

	server, err := chaincode.GetChaincodeServer(tee.ChaincodeName)
	if err != nil {
		responseJSON(o.Controller, false, err.Error())
		return
	}

	logger.Infof("GetAll by owner: %s", owner)
	result, err := server.Query([]string{"queryDataByOwner", owner})
	if err != nil {
		responseJSON(o.Controller, false, err.Error())
		return
	}

	var dataList [][]byte
	if err = json.Unmarshal([]byte(result), &dataList); err != nil {
		responseJSON(o.Controller, false, err.Error())
		return
	}

	var d tee.SharedData
	dList := make([]tee.SharedData, 0)
	for _, data := range dataList {
		if err = json.Unmarshal([]byte(data), &d); err != nil {
			responseJSON(o.Controller, false, err.Error())
			return
		}

		dList = append(dList, d)
	}

	responseJSON(o.Controller, true, dList)
}

// Get users can get shared data with the specified id
// @Title Get
// @Description users can get shared data with the specified id
// @Param	id		path 	string	true		"Data id for user shared data. It is generated by the server after the data is uploaded."
// @Success 200 {object} tee.SharedData
// @router /:id [get]
func (o *SharedDataController) Get() {
	id := o.GetString(":id")
	logger.Infof("Get data by id: %s", id)

	d, err := tee.GetData(id)
	if err != nil {
		responseJSON(o.Controller, false, err.Error())
		return
	}

	responseJSON(o.Controller, true, d)
}

// Update the uploaded data, regenerate the data summary, and modify the data description
// @Title Update
// @Description update the uploaded data, regenerate the data summary, and modify the data description
// @Param	id				path 		string		true	"Data id for user shared data. It is generated by the server after the data is uploaded."
// @Param	ciphertext		formData 	string		true	"Encrypted ciphertext for user shared data. Generally use private key encryption."
// @Param	summary			formData 	string		true	"Data summary for user to share data. Generally use SHA-256/MD5 calculation."
// @Param	description		formData 	string		true	"Data description for user to share data. Generally used to explain data usage."
// @Param	hash			formData 	string		false	"All parameters except the signature are sequentially connected to obtain a hash."
// @Param	signatures		formData 	[]string	false	"Signature of the data summary by the user's private key."
// @Success 200	string	Updated successfully
// @router /:id [put]
func (o *SharedDataController) Update() {
	var data tee.SharedData
	var err error
	if err = o.ParseForm(&data); err != nil {
		responseJSON(o.Controller, false, err.Error())
		return
	}

	hash := o.GetString("hash")
	if len(data.Signatures) == 0 {
		data.Signatures = make([]string, 1)
	}
	signature, err := json.Marshal(data.Signatures)
	if err != nil {
		responseJSON(o.Controller, false, err.Error())
		return
	}

	server, err := chaincode.GetChaincodeServer(tee.ChaincodeName)
	if err != nil {
		responseJSON(o.Controller, false, err.Error())
		return
	}

	id := o.GetString(":id")
	result, err := server.Invoke([]string{"update", id, data.Ciphertext, data.Hash, data.Description, hash, string(signature)})
	if err != nil {
		responseJSON(o.Controller, false, err.Error())
		return
	}

	logger.Infof("Update by id: %s returns result: %s", id, result)
	responseJSON(o.Controller, true, "Updated successfully")
}

// Request to view user data, this will send a notification to the data owner and will receive a reminder.
// @Title Request
// @Description Request to view user data, this will send a notification to the data owner and will receive a reminder.
// @Param	id			formData 	string		true	"Data id for user shared data. It is generated by the server after the data is uploaded."
// @Param	requester	formData 	string		true	"A data requester requesting to view data shared by others. The requester public key is generally used."
// @Param	hash		formData 	string		false	"All parameters except the signature are sequentially connected to obtain a hash."
// @Param	signatures	formData 	[]string	false	"Signature of the data summary by the user's private key."
// @Success 200 {string} Requested successfully
// @router /request/ [post]
func (o *SharedDataController) Request() {
	id, requester := o.GetString("id"), o.GetString("requester")

	server, err := chaincode.GetChaincodeServer(tee.ChaincodeName)
	if err != nil {
		responseJSON(o.Controller, false, err.Error())
		return
	}

	hash, signatures := o.GetString("hash"), o.GetStrings("signatures")
	if len(signatures) == 0 {
		signatures = make([]string, 1)
	}
	signature, err := json.Marshal(signatures)
	if err != nil {
		responseJSON(o.Controller, false, err.Error())
		return
	}

	result, err := server.Invoke([]string{"request", id, requester, hash, string(signature)})
	if err != nil {
		responseJSON(o.Controller, false, err.Error())
		return
	}
	logger.Infof("Request by id: %v and requester:%v returns result: %s", id, requester, result)

	var notification tee.Notification
	if err = json.Unmarshal([]byte(result), &notification); err != nil {
		responseJSON(o.Controller, false, err.Error())
		return
	}

	logger.Infof("Received a new notification: %v", notification)
	responseJSON(o.Controller, true, "Requested successfully")
}

// GetAllRequests Query all requests you send as a requester and view the authorization information for your requests.
// @Title GetAllRequest
// @Description Query all requests you send as a requester and view the authorization information for your requests.
// @Param	requester	query 	string	true		"A data requester requesting to view data shared by others. The requester public key is generally used."
// @Param	id			query 	string	false		"Data id for user shared data. It is generated by the server after the data is uploaded."
// @Param	status		query 	string	false		"Authorization result. 0 - Unauthorized, 1 - Agree to authorize, 2 - Deny authorization."
// @Success 200 {object} []tee.Notification
// @router /request/ [get]
func (o *SharedDataController) GetAllRequests() {
	requester, id, status := o.GetString("requester"), o.GetString("id"), o.GetString("status")

	var args []string
	if status == "" {
		args = []string{"queryRequestsByRequesterAndDID", requester, id}
	} else {
		args = []string{"queryRequestsByRequesterAndStatusAndDID", requester, status, id}
	}

	server, err := chaincode.GetChaincodeServer(tee.ChaincodeName)
	if err != nil {
		responseJSON(o.Controller, false, err.Error())
		return
	}

	result, err := server.Query(args)
	if err != nil {
		responseJSON(o.Controller, false, err.Error())
		return
	}
	logger.Infof("GetAllRequests by requester:%v and id: %v and status: %v returns result: %s", requester, id, status, result)

	var dataList [][]byte
	if err = json.Unmarshal([]byte(result), &dataList); err != nil {
		responseJSON(o.Controller, false, err.Error())
		return
	}

	var request tee.Notification
	requests := make([]tee.Notification, 0)
	for _, data := range dataList {
		if err = json.Unmarshal([]byte(data), &request); err != nil {
			responseJSON(o.Controller, false, err.Error())
			return
		}

		requests = append(requests, request)
	}

	logger.Infof("Received a requests: %v", requests)
	responseJSON(o.Controller, true, requests)
}

// GetAllNotificaitons Query all notifications you receive as data owners and authorize or reject requests.
// @Title GetAllNotificaitons
// @Description Query all notifications you receive as data owners and authorize or reject requests
// @Param	owner		query 	string	true		"Data owner for user shared data. Generally use owner public key."
// @Param	id			query 	string	false		"Data id for user shared data. It is generated by the server after the data is uploaded."
// @Param	requester	query 	string	false		"A data requester requesting to view data shared by others. The requester public key is generally used."
// @Param	status		query 	string	false		"Authorization result. 0 - Unauthorized, 1 - Agree to authorize, 2 - Deny authorization."
// @Success 200 {object} []tee.Notification
// @router /notification/ [get]
func (o *SharedDataController) GetAllNotificaitons() {
	owner, id, requester, status := o.GetString("owner"), o.GetString("id"), o.GetString("requester"), o.GetString("status")

	var args []string
	switch {
	case requester == "" && status == "":
		args = []string{"queryNotificationsByOwnerAndDID", owner, id}
	case requester != "" && status == "":
		args = []string{"queryNotificationsByOwnerAndRequesterAndDID", owner, requester, id}
	case requester == "" && status != "":
		args = []string{"queryNotificationsByOwnerAndStatusAndDID", owner, status, id}
	default:
		args = []string{"queryNotificationsByOwnerAndRequesterAndStatusAndDID", owner, requester, status, id}

	}

	server, err := chaincode.GetChaincodeServer(tee.ChaincodeName)
	if err != nil {
		responseJSON(o.Controller, false, err.Error())
		return
	}

	result, err := server.Query(args)
	if err != nil {
		responseJSON(o.Controller, false, err.Error())
		return
	}
	logger.Infof("GetAllNotificaitons by owner: %v and id: %v and requester:%v and status: %v returns result: %s", owner, id, requester, status, result)

	var dataList [][]byte
	if err = json.Unmarshal([]byte(result), &dataList); err != nil {
		responseJSON(o.Controller, false, err.Error())
		return
	}

	var notification tee.Notification
	notifications := make([]tee.Notification, 0)
	for _, data := range dataList {
		if err = json.Unmarshal([]byte(data), &notification); err != nil {
			responseJSON(o.Controller, false, err.Error())
			return
		}

		notifications = append(notifications, notification)
	}

	logger.Infof("Received notifications: %v", notifications)
	responseJSON(o.Controller, true, notifications)
}

// Authorize whether the license agrees to this user to view this data
// @Title Authorize
// @Description Authorize whether the license agrees to this user to view this data
// @Param	id				formData 	string		true	"The ID of the notification, used for authorization or refusal."
// @Param	status			formData 	string		true	"Authorization result. 0 - Unauthorized, 1 - Agree to authorize, 2 - Deny authorization."
// @Param	message			formData 	string		true	"If the status is authorized, the message is the encrypted ciphertext, and if it is refused, the message is refused reason."
// @Param	dataStoreType	formData 	string		false	"The DataStoreType is used to describe the type of data storage for authorization. 0-local 1-azure"
// @Param	encryptedKey	formData 	string		false	"EncryptedKey is the ciphertext after the symmetric key is encrypted with the public key."
// @Param	encryptedType	formData 	string		false	"EncryptedType for tee shared data. 0-unencrypted, 1-addressOnly, 2-dataOnly, 3-all."
// @Param	hash			formData 	string		false	"All parameters except the signature are sequentially connected to obtain a hash."
// @Param	signatures		formData 	[]string	false	"Signature of the data summary by the user's private key."
// @Success 200 {string} Authorized successfully
// @router /authorize/ [put]
func (o *SharedDataController) Authorize() {
	id, status, message := o.GetString("id"), o.GetString("status"), o.GetString("message")
	dataStoreType, encryptedKey, encryptedType := o.GetString("dataStoreType", "0"), o.GetString("encryptedKey", "nokey"), o.GetString("encryptedType", "0")

	server, err := chaincode.GetChaincodeServer(tee.ChaincodeName)
	if err != nil {
		responseJSON(o.Controller, false, err.Error())
		return
	}

	hash, signatures := o.GetString("hash"), o.GetStrings("signatures")
	if len(signatures) == 0 {
		signatures = make([]string, 1)
	}
	signature, err := json.Marshal(signatures)
	if err != nil {
		responseJSON(o.Controller, false, err.Error())
		return
	}

	result, err := server.Invoke([]string{"authorize", id, status, message, dataStoreType, encryptedKey, encryptedType, hash, string(signature)})
	if err != nil {
		responseJSON(o.Controller, false, err.Error())
		return
	}
	logger.Infof("Authorize by id: %v and status:%v and message:%v returns result: %s", id, status, message, result)

	responseJSON(o.Controller, true, "Authorized successfully")
}

// GetHistory to view user data history version
// @Title GetHistory
// @Description Request to view user data history version
// @Param	id		path	string	true		"Data id for user shared data. It is generated by the server after the data is uploaded."
// @Success 200 {string} GetHistory successfully
// @router /history/:id [get]
func (o *SharedDataController) GetHistory() {
	id := o.GetString(":id")

	server, err := chaincode.GetChaincodeServer(tee.ChaincodeName)
	if err != nil {
		responseJSON(o.Controller, false, err.Error())
		return
	}

	result, err := server.Invoke([]string{"queryHistoryByDID", id})
	if err != nil {
		responseJSON(o.Controller, false, err.Error())
		return
	}
	logger.Infof("GetHistory by id: %v returns result: %s", id, result)

	var dataList []*tee.SharedData
	if err = json.Unmarshal([]byte(result), &dataList); err != nil {
		responseJSON(o.Controller, false, err.Error())
		return
	}

	responseJSON(o.Controller, true, dataList)
}
